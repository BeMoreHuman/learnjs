# learnjs
Tasks for learn.javascript.ru

#### Основы JavaScript
###### Урок 1

- тег script

###### Урок 2

- внешние скрипты, порядок исполнения

###### Урок 3

- структура кода

###### Урок 4

- современный стандарт, "use strict"

###### Урок 5

- переменные

###### Урок 6

- выбор имени переменной

###### Урок 7

- шесть типов данных, typeof

###### Урок 8

- основные операторы

###### Урок 9

- операторы сравнения и логические значения

###### Урок 10

- побитовые операторы

###### Урок 11

- взаимодействие с пользователем: alert, prompt, confirm

###### Урок 12

- условные операторы: if, '?'

###### Урок 13

- логические операторы

###### Урок 14

- преобразование типов для примитивов

###### Урок 15

- циклы while, for

###### Урок 16

- конструкция switch

###### Урок 17

- функции

###### Урок 18

- функциональные выражения

###### Урок 19

- рекурсия, стек

###### Урок 20

- именованные функциональные выражения

---

#### Структуры данных
###### Урок 1

- Введение в методы и свойства

###### Урок 2

- Числа

---

#### Замыкания, область видимости
###### Урок 1, Глобальный объект

- В результате инициализации, к началу выполнения кода:

> - Функции, объявленные как **Function Declaration**, создаются полностью и готовы к использованию.
> - Переменные объявлены, но равны **undefined**. Присваивания выполнятся позже, когда выполнение дойдет до них.

###### Урок 2, Замыкания, функции изнутри

- Лексическое окружение, Доступ ко внешним переменным:

> - Каждая функция при создании получает ссылку **[[Scope]]** на объект с переменными, в контексте которого была создана.
> - При запуске функции создаётся новый объект с переменными **LexicalEnvironment**. Он получает ссылку на внешний объект переменных из **[[Scope]]**.
> - При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.

- Замыкания:

> - Все переменные и параметры функций являются свойствами объекта переменных **LexicalEnvironment**. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – **window**.
> - При создании функция получает системное свойство **[[Scope]]**, которое ссылается на **LexicalEnvironment**, в котором она была создана.
> - При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних **LexicalEnvironment** с места своего «рождения».

###### Урок 3, [[Scope]] для new Function

> - При создании функции с использованием **new Function**, её свойство **[[Scope]]** ссылается не на текущий **LexicalEnvironment**, а на **window**.

###### Урок 4, Локальные переменные для объекта

###### Урок 5, Модули через замыкания

- Итого:

> - **Модуль** при помощи замыканий – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется. **«Модуль»** – это всего лишь функция-обёртка для скрытия переменных.

```
;(function() {
  // code
})();
```

###### Урок 6, Управление памятью в JavaScript

###### Урок 7, Устаревшая конструкция "with"

- Итого:

> - Конструкция **with(obj) { ... }** использует **obj** как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в **obj**.

---

#### Методы объектов и контекст вызова
###### Урок 1, Методы объектов, this

- Доступ к объекту через this

> - Для доступа к текущему объекту из метода используется ключевое слово **this**.

- Подробнее про this

> - Любая функция может иметь в себе **this**. Совершенно неважно, объявлена ли она в объекте или отдельно от него. 

> - Значение **this** называется *контекстом вызова* и будет определено в момент вызова функции.

> - Значение **this** не зависит от того, как функция была создана, оно определяется исключительно в момент вызова.

###### Урок 2, Преобразование объектов: toString и valueOf

- Итого:

> - В логическом контексте объект – всегда **true**.

> - При строковом преобразовании объекта используется его метод **toString**. Он должен возвращать примитивное значение, причём не обязательно именно строку.

> - Для численного преобразования используется метод **valueOf**, который также может возвратить любое примитивное значение. У большинства объектов **valueOf** не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется **toString**.









