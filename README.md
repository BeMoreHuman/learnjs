# learnjs
Tasks for learn.javascript.ru

#### Основы JavaScript
###### Урок 1

- тег script

###### Урок 2

- внешние скрипты, порядок исполнения

###### Урок 3

- структура кода

###### Урок 4

- современный стандарт, "use strict"

###### Урок 5

- переменные

###### Урок 6

- выбор имени переменной

###### Урок 7

- шесть типов данных, typeof

###### Урок 8

- основные операторы

###### Урок 9

- операторы сравнения и логические значения

###### Урок 10

- побитовые операторы

###### Урок 11

- взаимодействие с пользователем: alert, prompt, confirm

###### Урок 12

- условные операторы: if, '?'

###### Урок 13

- логические операторы

###### Урок 14

- преобразование типов для примитивов

###### Урок 15

- циклы while, for

###### Урок 16

- конструкция switch

###### Урок 17

- функции

###### Урок 18

- функциональные выражения

###### Урок 19

- рекурсия, стек

###### Урок 20

- именованные функциональные выражения

---

#### Структуры данных
###### Урок 1

- Введение в методы и свойства

###### Урок 2

- Числа

---

#### Замыкания, область видимости
###### Урок 1, Глобальный объект

- В результате инициализации, к началу выполнения кода:

> - Функции, объявленные как **Function Declaration**, создаются полностью и готовы к использованию.
> - Переменные объявлены, но равны **undefined**. Присваивания выполнятся позже, когда выполнение дойдет до них.

###### Урок 2, Замыкания, функции изнутри

- Лексическое окружение, Доступ ко внешним переменным:

> - Каждая функция при создании получает ссылку **[[Scope]]** на объект с переменными, в контексте которого была создана.
> - При запуске функции создаётся новый объект с переменными **LexicalEnvironment**. Он получает ссылку на внешний объект переменных из **[[Scope]]**.
> - При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.

- Замыкания:

> - Все переменные и параметры функций являются свойствами объекта переменных **LexicalEnvironment**. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – **window**.
> - При создании функция получает системное свойство **[[Scope]]**, которое ссылается на **LexicalEnvironment**, в котором она была создана.
> - При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних **LexicalEnvironment** с места своего «рождения».

###### Урок 3, [[Scope]] для new Function

> - При создании функции с использованием **new Function**, её свойство **[[Scope]]** ссылается не на текущий **LexicalEnvironment**, а на **window**.

###### Урок 4, Локальные переменные для объекта

###### Урок 5, Модули через замыкания

- Итого:

> - **Модуль** при помощи замыканий – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется. **«Модуль»** – это всего лишь функция-обёртка для скрытия переменных.

```
;(function() {
  // code
})();
```

###### Урок 6, Управление памятью в JavaScript

###### Урок 7, Устаревшая конструкция "with"

- Итого:

> - Конструкция **with(obj) { ... }** использует **obj** как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в **obj**.

---

#### Методы объектов и контекст вызова
###### Урок 1, Методы объектов, this

- Доступ к объекту через this

> - Для доступа к текущему объекту из метода используется ключевое слово **this**.

- Подробнее про this

> - Любая функция может иметь в себе **this**. Совершенно неважно, объявлена ли она в объекте или отдельно от него. 

> - Значение **this** называется *контекстом вызова* и будет определено в момент вызова функции.

> - Значение **this** не зависит от того, как функция была создана, оно определяется исключительно в момент вызова.

###### Урок 2, Преобразование объектов: toString и valueOf

- Итого:

> - В логическом контексте объект – всегда **true**.

> - При строковом преобразовании объекта используется его метод **toString**. Он должен возвращать примитивное значение, причём не обязательно именно строку.

> - Для численного преобразования используется метод **valueOf**, который также может возвратить любое примитивное значение. У большинства объектов **valueOf** не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется **toString**.

###### Урок 3, Создание объектов через "new"

- Итого:

> - Любая функция может быть вызвана с `new`, при этом она получает новый пустой объект в качестве `this`, в который она добавляет свойства. Если функция не решит возвратить свой объект, то её результатом будет `this`.

> - Функции, которые предназначены для создания объектов, называются *конструкторами*. Их названия пишут с большой буквы, чтобы отличать от обычных.

###### Урок 4, Дескрипторы, геттеры и сеттеры свойств

###### Урок 5, Статические и фабричные методы

> Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют *«статическими»*. Их записывают прямо в саму функцию-конструктор.

> **"Фабричный статический метод" – удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется «фабричным»).**

- Итого:

Статические свойства и методы объекта удобно применять в следующих случаях:

> - Общие действия и подсчёты, имеющие отношения ко всем объектам данного типа. В примерах выше это подсчёт количества.

> - Методы, не привязанные к конкретному объекту, например сравнение.

> - Вспомогательные методы, которые полезны вне объекта, например для форматирования даты.

> - Фабричные методы.

###### Урок 6, Явное указание this: "call", "apply"

- Итого про this:
> Итак, мы знаем, что `this` – это текущий объект при вызове «через точку» и новый объект при конструировании через `new`.
> Значение `this` устанавливается в зависимости от того, как вызвана функция:

> - При вызове функции как метода:
```js
obj.func(...)    // this = obj
obj["func"](...)
```

> - При обычном вызове:
```js
func(...) // this = window (ES3) /undefined (ES5)
```

> - В `new`:
```js
new func() // this = {} (новый объект)
```

> - Явное указание:
```js
func.apply(context, args) // this = context (явная передача)
func.call(context, arg1, arg2, ...)
```

###### Урок 7, Привязка контекста и карринг: "bind"












