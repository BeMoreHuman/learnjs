// Числа могут быть записаны в десятеричной, шестнадцатиричной системах, а также «научным» способом.
// В JavaScript существует числовое значение бесконечность Infinity.
// Ошибка вычислений дает NaN.
// Арифметические и математические функции преобразуют строку в точности в число, игнорируя начальные и конечные пробелы.
// Функции parseInt/parseFloat делают числа из строк, которые начинаются с числа.
// Есть четыре способа округления: Math.floor, Math.round, Math.ceil и битовый оператор. Для округления до нужного знака используйте +n.toFixed(p) или трюк с умножением и делением на 10p.
// Дробные числа дают ошибку вычислений. При необходимости ее можно отсечь округлением до нужного знака.
// Случайные числа от 0 до 1 генерируются с помощью Math.random(), остальные – преобразованием из них.

// Task #1: Создайте страницу, которая предлагает ввести два числа и выводит их сумму.
function sumTwoNumbers() {
	const firstNum = Number(prompt('Введите первое число'));
	const secondNum = Number(prompt('Введите второе число'));
	const result = firstNum + secondNum;

	return result;
}
alert(sumTwoNumbers());

// Task #2: Избежать проблем с округлением.
// Представьте себе электронный магазин. Цены даны с точностью до копейки(цента, евроцента и т.п.).
// Вы пишете интерфейс для него. Основная работа происходит на сервере, но и на клиенте все должно быть хорошо. 
// Сложение цен на купленные товары и умножение их на количество является обычной операцией.
// Получится глупо, если при заказе двух товаров с ценами 0.10$ и 0.20$ человек получит общую стоимость 0.30000000000000004$:
// alert( 0.1 + 0.2 + '$' ); => 0.30000000000000004$
function showBill(firstNum, secondNum) {
	return Number((firstNum + secondNum).toFixed(2));
}

// Task #2: Этот цикл – бесконечный. Почему?
// Этот цикл – бесконечный. Почему?
// var i = 0;
// while (i != 10) {
//   i += 0.2;
// }
// => происходят неточности в прибавлении 0.2
// Запустить для наглядности.
// var i = 0;
// while (i < 11) {
//   i += 0.2;
// 	 console.log(i);
//   if (i > 11 && i < 12) alert( i );
// }

// Task #3: Формула Бине
// Последовательность чисел Фибоначчи имеет формулу Fn = Fn-1 + Fn-2. То есть, следующее число получается как сумма двух предыдущих.
// Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
// Код для их вычисления (из задачи Числа Фибоначчи):
// function fib(n) {
//   var a = 1,
//     b = 0,
//     x;
//   for (i = 0; i < n; i++) {
//     x = a + b;
//     a = b
//     b = x;
//   }
//   return b;
// }
// Существует формула Бине, согласно которой Fn равно ближайшему целому для ϕn/√5, где ϕ=(1+√5)/2 – золотое сечение.
// Напишите функцию fibBinet(n), которая будет вычислять Fn, используя эту формулу. 
// Проверьте её для значения F77 (должно получиться fibBinet(77) = 5527939700884757).
// Одинаковы ли результаты, полученные при помощи кода fib(n) выше и по формуле Бине? 
// Если нет, то почему и какой из них верный?
function fibBinet(n) {
	const a = (1 + Math.sqrt(5)) / 2;
	const b = Math.pow(a, n) / Math.sqrt(5);

	return b;
} // => 5527939700884755
// => результаты не одинаковы
// Причина – в ошибках округления, ведь √5 – бесконечная дробь.

// Task #4: Случайное из интервала (0, max)
// Напишите код для генерации случайного значения в диапазоне от 0 до max, не включая max.
function rnd(max) {
	const min = 0;

	return Math.random() * (max - min) + min;
}

// Task #5: Случайное из интервала (min, max)
// Напишите код для генерации случайного значения в диапазоне от min до max, не включая max.
function rnd(min, max) {
	return Math.random() * (max - min) + min;
}

// Task #6: Случайное целое от min до max
// Напишите функцию randomInteger(min, max) для генерации случайного целого числа между min и max,
// включая min,max как возможные значения.
// Любое число из интервала min..max должно иметь одинаковую вероятность.
function rnd(min, max) {
	// Использование метода Math.round() даст неравномерное распределение!
	return Math.floor(Math.random() * (max + 1 - min)) + min;
}
